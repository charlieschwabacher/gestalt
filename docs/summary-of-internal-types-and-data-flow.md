# Summary of flow types


### GraphQL Types

Gestalt makes extensive use of the flow types exported by graphql-js describing
the graphql language AST and schema objects.


### Gestalt GraphQL Types

- `DatabaseInterface`
  - Interface between database specific and non specific parts of Gestalt -
    although right now there is only a PostgreSQL interface, adapters can be
    created for other databases.  Includes a node resolution function, a
    function to generate relationship resolvers from relationship objects, and a
    function to prepare the context before resolving graphql queries.

- `Relationship`
  - `RelationshipSegment`
  - `RelationshipSegmentPair`


### Gestalt Postgres Types

- `DatabaseSchema`
  Includes information on the structure of the PostgreSQL database schema.

- `RelationshipSegmentDescription`
  - `JoinTableDescription`
  - `ForeignKeyDescription`

- `Query`
  - `Join`
  - `Condition`
  - `Order`

- `DatabaseSchemaMigration`
  - Includes a list of migration operations to perform on the database.
  - Gestalt will only perform non destructive operations, so only these are
    represented.
  - `DatabaseSchemaMigration` objects are generated by comapring expected and
    existing `DatabaseSchema` objects.


## data flow between types

- when we load a graphql schema
  - we start with a a string of GraphQL IDL code defining out schema
  - we parse this into a (graphql-js) AST `Document` object
  - we generate a `DatabaseRelevantSchemaInfo` object from the AST.
  - we generate a (graphql-js) `GraphQLSchema` object from the AST (which does
    not yet have resolution defined)
  - we pass `DatabaseReleventSchemaInfo` to functions defined by our database
    interface to define resolvers and attach them to the `GraphQLSchema`.
  - we attach user defined resolvers to the `GraphQLSchema`

- when we generate a database interface
  - we start with our `DatabaseReleventSchemaInfo` object
  - we take the `Relationship` objects in our `DatabaseReleventSchemaInfo` and
    generate a `RelationshipSegmentDescriptionMap` which includes information on
    how we will store relationships in the database.
    - first, we create a flat array of unique relationship segments
    - we generate a 'pairing signature' for each segment
    - we use the pairing signatures to find matching segment pairs
    - for each pair we generate a `RelationshipSegmentDescription` object
      describing how we plan to store the relationship in the database
    - we create the `RelationshipSegmentDescriptionMap` by indexing the segment
      descriptions by their signatures
  - we generate a `DataLoader` for each `Relationship` by consulting the our
    `RelationshipSegmentDescriptionMap`.  These let us batch requests to load
    data from the database.
    - we generate a `Query` object for each relationship using the
      `Relationship` and `RelationshipSegmentDescriptionMap` objects.  The
    - when using connection arguments we have methods that modify the `Query` to
      order and page through data
    - to load data, we generate a SQL strings from our `Query` object
  - we generate simple relationship resolvers that load data through their
    `DataLoader`
  - we use our `DatabaseReleventSchemaInfo` and `RelationshipSegmentDescription`
    objects to generate a `DatabaseSchema`

- when we generate a schema migration
  - we create a `DatabaseSchema` object from our GraphQL IDL schema
  - we create a `DatabaseSchema` object by reading the schema of our PostgreSQL
    database
  - we compare the two schmeas, generating an array of
    `DatabaseScheamMigrationOperation` objects describing the updates needed to
    transform the existing schema into the expected schema
  - we generate a string of SQL from these `DatabaseScheamMigrationOperation`
    objects
  - we return a `DatabaseSchemaMigration` objecting containing both the SQL
    migration and the array of operations
